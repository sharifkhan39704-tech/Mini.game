<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>mini Console V - Ultra Pro</title>
    <style>
        :root { 
            --console-bg-1: #1e272e;
            --console-bg-2: #485460;
            --screen-bg: #0b0c10;
            --neon-blue: #00d2d3;
            --neon-pink: #fd79a8;
        }
        
        body { 
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e); 
            color: white; display: flex; justify-content: center; align-items: center; 
            height: 100vh; margin: 0; font-family: 'Courier New', monospace; 
            overflow: hidden; touch-action: none; user-select: none;
        }
        
        .console { 
            width: 360px; height: 720px; 
            background: linear-gradient(145deg, var(--console-bg-1), var(--console-bg-2));
            border-radius: 40px 40px 60px 60px; padding: 20px; 
            box-shadow: 0 20px 50px rgba(0,0,0,0.9), inset 3px 3px 10px rgba(255,255,255,0.2), inset -5px -5px 15px rgba(0,0,0,0.6);
            display: flex; flex-direction: column; align-items: center;
            border: 2px solid #575fcf;
        }
        
        .screen-bezel {
            width: 95%; padding: 15px 15px 25px 15px;
            background: #1e272e; border-radius: 15px 15px 25px 25px;
            margin-bottom: 25px; border: 2px solid #000;
            box-shadow: inset 0 5px 15px rgba(0,0,0,0.9), 0 5px 10px rgba(0,0,0,0.5);
        }

        .lcd {
            width: 100%; height: 300px; 
            background: var(--screen-bg);
            border: 3px solid #000; border-radius: 8px;
            position: relative; overflow: hidden;
            box-shadow: inset 0 0 25px rgba(0, 243, 255, 0.2);
        }
        
        .lcd::after {
            content: " "; display: block; position: absolute; top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2; background-size: 100% 2px, 3px 100%; pointer-events: none;
        }

        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        .controls-area { width: 100%; flex-grow: 1; display: flex; flex-direction: column; position: relative; }
        .sys-buttons { display: flex; justify-content: center; gap: 20px; margin-bottom: 15px; }
        
        .sys-btn {
            background: #2d3436; border: 2px solid #111; color: #b2bec3;
            padding: 8px 20px; border-radius: 20px; font-size: 11px; font-weight: bold;
            box-shadow: 0 4px #111, inset 0 2px rgba(255,255,255,0.1); cursor: pointer; letter-spacing: 2px;
        }
        .sys-btn:active { transform: translateY(4px); box-shadow: 0 0 #111; color: white; }

        .d-pad { margin-top: 15px; margin-left: 15px; display: grid; grid-template-columns: 60px 60px 60px; grid-template-rows: 60px 60px 60px; align-self: flex-start; }
        
        .btn {
            width: 60px; height: 60px; background: #2f3542; border: none;
            box-shadow: 0 6px #111, inset 0 2px rgba(255,255,255,0.2); 
            border-radius: 8px; cursor: pointer; color: #747d8c; font-size: 20px; display: flex; justify-content: center; align-items: center;
        }
        .btn:active { transform: translateY(6px); box-shadow: inset 0 2px rgba(0,0,0,0.5); color: var(--neon-blue); }
        
        .action-group { position: absolute; right: 15px; bottom: 40px; display: flex; gap: 20px; transform: rotate(-20deg); }
        
        .ab-btn { width: 70px; height: 70px; border-radius: 50%; border: none; font-weight: bold; font-size: 24px; color: white; cursor: pointer; box-shadow: 0 6px #111, inset 0 5px rgba(255,255,255,0.3); text-shadow: 0 2px 2px rgba(0,0,0,0.5); }
        .ab-btn:active { transform: translateY(6px); box-shadow: inset 0 2px rgba(0,0,0,0.5); }
        .btn-a { background: #fd79a8; } 
        .btn-b { background: #00cec9; } 

        .branding { font-size: 12px; color: #b2bec3; letter-spacing: 2px; text-transform: uppercase; font-weight: bold; display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .led { width: 8px; height: 8px; background: #333; border-radius: 50%; box-shadow: 0 0 2px #000; inset 0 1px rgba(255,255,255,0.2); }
        .led.on { background: #00ff00; box-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00; }
    </style>
</head>
<body>

<div class="console">
    <div class="screen-bezel">
        <div class="branding">
            <div class="led" id="pwr-led"></div>
            <span>mini SYSTEM V - ULTRA</span>
            <div class="led on"></div>
        </div>
        <div class="lcd">
            <canvas id="gc" width="300" height="300"></canvas>
        </div>
    </div>

    <div class="controls-area">
        <div class="sys-buttons">
            <button class="sys-btn" ontouchstart="input('back')" onmousedown="input('back')">MENU</button>
        </div>

        <div class="d-pad">
            <button class="btn" style="grid-column: 2" ontouchstart="input('up')" onmousedown="input('')">▲</button>
            <button class="btn" style="grid-column: 1; grid-row: 2" ontouchstart="input('left')" onmousedown="input('')">◀</button>
            <button class="btn" style="grid-column: 3; grid-row: 2" ontouchstart="input('right')" onmousedown="input('')">▶</button>
            <button class="btn" style="grid-column: 2; grid-row: 3" ontouchstart="input('down')" onmousedown="input('')">▼</button>
        </div>
        
        <div class="action-group">
            <button class="ab-btn btn-b" ontouchstart="input('B')" onmousedown="input('')">B</button>
            <button class="ab-btn btn-a" ontouchstart="input('A')" onmousedown="input('')">A</button>
        </div>
    </div>
</div>

<script>
    let bgName = "SHARIF"; 
    const canvas = document.getElementById('gc');
    const ctx = canvas.getContext('2d');

    // --- Audio System ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playTone(freq, type='square', duration=0.9) {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.05, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime + duration);
    }
    function sfx(type) {
        if(type === 'move') playTone(200, 'triangle', 0.05);
        if(type === 'hit') { playTone(100, 'sawtooth', 0.2); playTone(50, 'square', 0.3); } 
        if(type === 'win') { playTone(400, 'square', 0.1); setTimeout(()=>playTone(600, 'square', 0.2), 100); }
        if(type === 'shoot') { playTone(800, 'sine', 0.1); }
        if(type === 'pause') playTone(300, 'sine', 0.2);
    }

    // --- Dynamic Background & Particles ---
    let particles = [];
    let stars = Array.from({length: 40}, () => ({x: Math.random()*300, y: Math.random()*300, s: Math.random()*2+1}));
    
    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y; this.color = color;
            this.vx = (Math.random() - 0.5) * 8; this.vy = (Math.random() - 0.5) * 8; this.life = 1.0;
        }
        update() { this.x += this.vx; this.y += this.vy; this.life -= 0.05; }
        draw(ctx) { ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, 4, 4); ctx.globalAlpha = 1.0; }
    }
    function spawnParticles(x, y, color, count=15) { for(let i=0; i<count; i++) particles.push(new Particle(x, y, color)); }

    function drawAnimatedBG() {
        ctx.fillStyle = '#050508'; ctx.fillRect(0, 0, 300, 300);
        ctx.fillStyle = '#ffffff';
        stars.forEach(star => {
            star.y += star.s;
            if(star.y > 300) { star.y = 0; star.x = Math.random()*300; }
            ctx.globalAlpha = star.s / 3;
            ctx.fillRect(star.x, star.y, star.s, star.s);
        });
        ctx.globalAlpha = 1.0;
        
        // 3D Neon Grid effect at bottom
        ctx.strokeStyle = 'rgba(108, 92, 231, 0.3)'; ctx.lineWidth = 1;
        for(let i=0; i<=300; i+=30) {
            ctx.beginPath(); ctx.moveTo(150, 150); ctx.lineTo(i, 300); ctx.stroke();
        }
        ctx.beginPath(); ctx.moveTo(0, 220); ctx.lineTo(300, 220); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, 260); ctx.lineTo(300, 260); ctx.stroke();

        ctx.save(); ctx.font = "bold 28px Courier New"; ctx.fillStyle = "rgba(0, 210, 211, 0.05)"; ctx.textAlign = "center";
        ctx.fillText(bgName, 150, 150); ctx.restore();
    }

    // --- Core Engine ---
    let state = 'MENU';
    let games = ["SNAKE", "TURBO RACER", "DINO RUN", "NEON BRICKS", "MEMORY GRID", "MATH QUIZ", "SLIDE PUZZLE", "SHADOW STRIKE"]; 
    let selIdx = 0; let currGame = null; let score = 0; let highScore = 0; let isPaused = false; 

    function getHighScore(idx) { return parseInt(localStorage.getItem('miniV5_hs_'+idx)) || 0; }
    function setHighScore(idx, s) { if(s > getHighScore(idx)) localStorage.setItem('miniV5_hs_'+idx, s); }

    function input(k) {
        if(!k) return;
        if(k === 'back') {
            if(state !== 'MENU') {
                if(state === 'PLAY' && currGame) setHighScore(selIdx, score);
                state = 'MENU'; isPaused = false; particles = []; sfx('pause');
            }
            return;
        }

        if(state === 'MENU') {
            sfx('move');
            if(k === 'up') selIdx = (selIdx - 1 + games.length) % games.length;
            if(k === 'down') selIdx = (selIdx + 1) % games.length;
            if(k === 'A' || k === 'right') startGame(selIdx);
        } else if(state === 'PLAY') {
            if(k === 'B') { isPaused = !isPaused; sfx('pause'); return; }
            if(!isPaused && currGame) currGame.input(k);
        } else if(state === 'GAMEOVER') {
            if(k === 'A') { state = 'MENU'; particles = []; }
            if(k === 'B') { startGame(selIdx); particles = []; } 
        }
    }

    function startGame(idx) {
        state = 'PLAY'; score = 0; isPaused = false; particles = []; highScore = getHighScore(idx);
        if(idx === 0) currGame = new SnakeGame();
        if(idx === 1) currGame = new CarGame();
        if(idx === 2) currGame = new DinoGame();
        if(idx === 3) currGame = new BrickGame();
        if(idx === 4) currGame = new MemoryGame();
        if(idx === 5) currGame = new MathGame();
        if(idx === 6) currGame = new SlidePuzzleGame(); 
        if(idx === 7) currGame = new ShadowStrikeGame(); // Naya Firing + Shadow Fight Game
    }

    // --- GAMES ---
    class SnakeGame {
        constructor(){ this.s = [{x:5, y:5}, {x:4, y:5}, {x:3, y:5}]; this.d = {x:1, y:0}; this.f = {x:10, y:10}; this.t = 0; this.blockSize = 20; }
        input(k){ if(k==='up' && this.d.y===0) this.d={x:0, y:-1}; if(k==='down' && this.d.y===0) this.d={x:0, y:1}; if(k==='left' && this.d.x===0) this.d={x:-1, y:0}; if(k==='right' && this.d.x===0) this.d={x:1, y:0}; }
        update(){
            let speed = Math.max(2, 12 - Math.floor(score/100)); if(++this.t % speed !== 0) return true;
            let h = {x:this.s[0].x + this.d.x, y:this.s[0].y + this.d.y};
            if(h.x < 0 || h.x >= 15 || h.y < 1 || h.y >= 15 || this.s.some(b=>b.x===h.x && b.y===h.y)) return false;
            this.s.unshift(h);
            if(h.x===this.f.x && h.y===this.f.y){ score += 10; sfx('win'); spawnParticles(h.x*this.blockSize, h.y*this.blockSize, '#ffff00'); this.f = {x:Math.floor(Math.random()*13)+1, y:Math.floor(Math.random()*13)+2}; } 
            else { this.s.pop(); } return true;
        }
        draw(){ 
            drawAnimatedBG(); let bSize = this.blockSize;
            this.s.forEach((b, i) => { ctx.fillStyle = (i === 0) ? '#00d2d3' : '#2ed573'; ctx.fillRect(b.x*bSize, b.y*bSize, bSize-1, bSize-1); }); 
            ctx.fillStyle = '#ff4757'; ctx.beginPath(); ctx.arc(this.f.x*bSize + bSize/2, this.f.y*bSize + bSize/2, bSize/2 - 2, 0, Math.PI*2); ctx.fill();
        }
    }

    class CarGame {
        constructor() { this.lanes = [80, 150, 220]; this.laneIdx = 1; this.cars = []; this.roadY = 0; this.speed = 6; this.t = 0; }
        input(k) { if(k==='left' && this.laneIdx > 0) this.laneIdx--; if(k==='right' && this.laneIdx < 2) this.laneIdx++; if(k==='A') this.speed = 10; else this.speed = 6 + Math.floor(score/100); }
        update() {
            this.speed = 6 + Math.floor(score/200); this.roadY += this.speed; if(this.roadY > 40) this.roadY = 0;
            if(++this.t % (40 - Math.min(20, Math.floor(score/50))) === 0) { this.cars.push({idx: Math.floor(Math.random()*3), y: -50, type: Math.floor(Math.random()*3)}); }
            let px = this.lanes[this.laneIdx], py = 240;
            for(let i=this.cars.length-1; i>=0; i--) {
                this.cars[i].y += this.speed - 2;
                if(this.cars[i].y > 320) { this.cars.splice(i,1); score+=10; }
                else if(this.cars[i].idx === this.laneIdx && Math.abs(this.cars[i].y - py) < 40) { spawnParticles(px, py, '#ff4757', 20); return false; }
            }
            return true;
        }
        draw() {
            drawAnimatedBG();
            ctx.fillStyle = 'rgba(99, 110, 114, 0.6)'; ctx.fillRect(40,0,220,300);
            ctx.strokeStyle = '#fff'; ctx.setLineDash([20,20]); ctx.lineDashOffset = -this.roadY;
            ctx.beginPath(); ctx.moveTo(113,0); ctx.lineTo(113,300); ctx.moveTo(186,0); ctx.lineTo(186,300); ctx.stroke(); ctx.setLineDash([]);
            this.cars.forEach(c => { ctx.fillStyle = c.type==0 ? '#a29bfe' : (c.type==1 ? '#ffeaa7' : '#55efc4'); let x = this.lanes[c.idx] - 15; ctx.fillRect(x, c.y, 30, 45); ctx.fillStyle='#000'; ctx.fillRect(x+2,c.y+5,26,10); });
            let x = this.lanes[this.laneIdx] - 15; ctx.fillStyle = '#ff4757'; ctx.fillRect(x, 240, 30, 45); ctx.fillStyle = '#000'; ctx.fillRect(x+2, 255, 26, 8); ctx.fillStyle = '#ff9ff3'; ctx.fillRect(x+5, 270, 5, 5); ctx.fillRect(x+20, 270, 5, 5); 
        }
    }

    class DinoGame {
        constructor(){ this.y = 220; this.dy = 0; this.g = true; this.obs = []; this.t = 0; this.frame = 0; }
        input(k){ if((k==='up'||k==='A') && this.g){ this.dy=-11; this.g=false; sfx('move'); } }
        update(){
            this.y += this.dy; if(!this.g) this.dy += 0.6; if(this.y > 220){ this.y = 220; this.g = true; this.dy = 0; } 
            if(this.g) this.frame = Math.floor(Date.now() / 100) % 2; else this.frame = 0;
            let spawnRate = Math.max(40, 70 - Math.floor(score/20)); if(++this.t % spawnRate === 0) this.obs.push({x:300, w:15});
            for(let i=this.obs.length-1; i>=0; i--){
                this.obs[i].x -= (5 + score/200); 
                if(this.obs[i].x < 45 && this.obs[i].x > 15 && this.y > 200) { spawnParticles(30, 220, '#ff4757'); return false; }
                if(this.obs[i].x < -20) { this.obs.splice(i,1); score+=5; }
            }
            return true;
        }
        draw(){ 
            drawAnimatedBG(); ctx.fillStyle='#fff'; ctx.fillRect(0,240,300,2); let dx = 20; let dy = this.y;
            ctx.fillStyle = '#2ed573'; ctx.fillRect(dx-5, dy+5, 5, 10); ctx.fillRect(dx, dy+10, 5, 5); ctx.fillRect(dx+5, dy+5, 15, 15); ctx.fillRect(dx+15, dy-5, 15, 10); ctx.fillRect(dx+25, dy, 5, 5);
            ctx.fillStyle = '#000'; ctx.fillRect(dx+18, dy-3, 3, 3);
            ctx.fillStyle = '#2ed573';
            if(this.frame === 0) { ctx.fillRect(dx+5, dy+20, 4, 5); ctx.fillRect(dx+15, dy+20, 4, 3); } else { ctx.fillRect(dx+5, dy+20, 4, 3); ctx.fillRect(dx+15, dy+20, 4, 5); }
            ctx.fillStyle='#ff4757'; this.obs.forEach(o => { ctx.fillRect(o.x, 220, 10, 20); ctx.fillRect(o.x-4, 225, 4, 8); ctx.fillRect(o.x+10, 228, 4, 8); }); 
        }
    }

    class BrickGame {
        constructor(){ this.p=120; this.b={x:150,y:200,dx:3,dy:-3}; this.br=[]; let cols=['#ff4757','#2ed573','#1e90ff','#ffa502']; for(let r=0;r<5;r++) for(let c=0;c<8;c++) this.br.push({x:c*35+12, y:r*15+40, v:1, c:cols[r%4]}); }
        input(k){if(k==='left')this.p-=25; if(k==='right')this.p+=25; if(this.p<0)this.p=0; if(this.p>240)this.p=240;}
        update(){
            this.b.x+=this.b.dx; this.b.y+=this.b.dy; if(this.b.x<0||this.b.x>300)this.b.dx*=-1; if(this.b.y<25)this.b.dy*=-1; 
            if(this.b.y>270 && this.b.y<280 && this.b.x>this.p && this.b.x<this.p+60){ this.b.dy = -Math.abs(this.b.dy); sfx('move'); this.b.dx = (this.b.x - (this.p+30)) * 0.15; }
            if(this.b.y>300) return false;
            this.br.forEach(r=>{ if(r.v && this.b.x>r.x && this.b.x<r.x+32 && this.b.y>r.y && this.b.y<r.y+12){ this.b.dy*=-1; r.v=0; score+=10; sfx('win'); spawnParticles(r.x+15, r.y+5, r.c); } });
            if(this.br.every(b=>b.v===0)) { score+=100; this.constructor(); } return true;
        }
        draw(){ 
            drawAnimatedBG(); ctx.fillStyle='#00d2d3'; ctx.fillRect(this.p,275,60,6); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(this.b.x,this.b.y,4,0,Math.PI*2); ctx.fill(); 
            this.br.forEach(r=>{ if(r.v){ ctx.fillStyle=r.c; ctx.fillRect(r.x,r.y,32,12); ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.fillRect(r.x,r.y+8,32,4); } });
        }    
    }

    class MemoryGame {
        constructor(){ this.cards=[]; let v=[1,1,2,2,3,3,4,4,5,5,6,6]; v.sort(()=>Math.random()-0.5); for(let i=0;i<12;i++) this.cards.push({val:v[i], s:0}); this.cur=0; this.flip=[]; this.wait=0; }
        input(k){
            if(this.wait>0)return;
            if(k==='left')this.cur=(this.cur-1+12)%12; if(k==='right')this.cur=(this.cur+1)%12; if(k==='up')this.cur=(this.cur-4+12)%12; if(k==='down')this.cur=(this.cur+4)%12;
            if(k==='A' && this.cards[this.cur].s===0){ this.cards[this.cur].s=1; this.flip.push(this.cur); sfx('move'); if(this.flip.length===2) this.wait=40; }
        }
        update(){
            if(this.wait>0 && --this.wait===0){
                let c1=this.cards[this.flip[0]], c2=this.cards[this.flip[1]];
                if(c1.val===c2.val){ c1.s=2; c2.s=2; score+=50; sfx('win'); let r = Math.floor(this.flip[0]/4), c = this.flip[0]%4; spawnParticles(55+c*60, 80+r*60, '#00ff00'); } else {c1.s=0; c2.s=0;}
                this.flip=[];
            }
            if(this.cards.every(c=>c.s===2)) { score+=200; setTimeout(()=>startGame(4), 1000); } return true;
        }
        draw(){ 
            drawAnimatedBG(); 
            for(let i=0;i<12;i++){ 
                let x=55+(i%4)*55, y=80+Math.floor(i/4)*60; 
                if(i===this.cur){ctx.strokeStyle='#fd79a8'; ctx.lineWidth=3; ctx.strokeRect(x-3,y-3,46,56);} 
                ctx.fillStyle=this.cards[i].s===0?'#444':(this.cards[i].s===2?'#111':'#eee'); ctx.fillRect(x,y,40,50); 
                if(this.cards[i].s!==0){ ctx.fillStyle=this.cards[i].s===2?'#0f0':'#000'; ctx.font='bold 20px Courier New'; ctx.fillText(this.cards[i].val, x+20, y+30); } else { ctx.fillStyle='#555'; ctx.font='10px Courier'; ctx.fillText("?", x+20, y+30); }    
            }
        }
    }

    class MathGame {
        constructor() { this.generateProblem(); this.timer = 10; this.selIdx = 0; }
        generateProblem() {
            let a = Math.floor(Math.random() * 20) + 1; let b = Math.floor(Math.random() * 20) + 1; let op = Math.random() > 0.5 ? '+' : '-';
            this.ques = `${a} ${op} ${b} = ?`; this.ans = op === '+' ? a + b : a - b; this.options = [this.ans];
            while(this.options.length < 4) { let fake = this.ans + (Math.floor(Math.random() * 10) - 5); if(!this.options.includes(fake)) this.options.push(fake); }
            this.options.sort(() => Math.random() - 0.5); 
        }
        input(k) {
            if(k === 'up') this.selIdx = (this.selIdx - 1 + 4) % 4; if(k === 'down') this.selIdx = (this.selIdx + 1) % 4;
            if(k === 'A') { if(this.options[this.selIdx] === this.ans) { score += 10; sfx('win'); this.timer = 10; this.generateProblem(); } else return false; }
        }
        update() { this.timer -= 1/60; if(this.timer <= 0) return false; return true; }
        draw() {
            drawAnimatedBG(); ctx.textAlign = 'center'; ctx.fillStyle = '#ff3f34'; ctx.fillRect(50, 40, (this.timer/10) * 200, 10);
            ctx.fillStyle = '#fff'; ctx.font = 'bold 30px Courier'; ctx.fillText(this.ques, 150, 100);
            this.options.forEach((opt, i) => { let y = 160 + i * 30; if(i === this.selIdx) { ctx.fillStyle = '#00d2d3'; ctx.fillText("> " + opt + " <", 150, y); } else { ctx.fillStyle = '#555'; ctx.fillText(opt, 150, y); } });
        }
    }

    class SlidePuzzleGame {
        constructor() {
            this.grid = [1,2,3,4,5,6,7,8,0];
            for(let i=0; i<150; i++) {
                let z = this.grid.indexOf(0); let moves = [];
                if(z % 3 !== 0) moves.push(z - 1); if(z % 3 !== 2) moves.push(z + 1);
                if(z > 2) moves.push(z - 3); if(z < 6) moves.push(z + 3);
                let swapIdx = moves[Math.floor(Math.random() * moves.length)];
                this.grid[z] = this.grid[swapIdx]; this.grid[swapIdx] = 0;
            }
            this.moves = 0;
        }
        input(k) {
            let z = this.grid.indexOf(0); let target = -1;
            if(k === 'right' && z % 3 !== 0) target = z - 1; if(k === 'left' && z % 3 !== 2) target = z + 1;
            if(k === 'down' && z > 2) target = z - 3; if(k === 'up' && z < 6) target = z + 3;
            if(target !== -1) { this.grid[z] = this.grid[target]; this.grid[target] = 0; this.moves++; sfx('move'); }
        }
        update() {
            let win = true; for(let i=0; i<8; i++) { if(this.grid[i] !== i+1) win = false; }
            if(win) { score += Math.max(10, 500 - (this.moves * 5)); sfx('win'); return false; }
            return true;
        }
        draw() {
            drawAnimatedBG(); ctx.fillStyle = '#b2bec3'; ctx.font = '14px Courier New'; ctx.textAlign = 'center'; ctx.fillText("MOVES: " + this.moves, 150, 45);
            let ox = 50, oy = 70, size = 60, gap = 5;
            for(let i=0; i<9; i++) {
                let val = this.grid[i]; if(val === 0) continue; 
                let c = i % 3, r = Math.floor(i / 3); let x = ox + c * (size + gap); let y = oy + r * (size + gap);
                ctx.fillStyle = '#6c5ce7'; ctx.fillRect(x, y, size, size); ctx.fillStyle = '#4834d4'; ctx.fillRect(x, y+size-5, size, 5);
                ctx.fillStyle = '#fff'; ctx.font = 'bold 24px Courier New'; ctx.textBaseline = 'middle'; ctx.fillText(val, x + size/2, y + size/2);
            }
        }
    }

    // --- NAYA GAME: SHADOW STRIKE (Firing + Shadow Fight vibe) ---
    class ShadowStrikeGame {
        constructor() {
            this.py = 150; // Player Y
            this.bullets = [];
            this.enemies = [];
            this.t = 0;
        }
        input(k) {
            if(k === 'up' && this.py > 50) this.py -= 25;
            if(k === 'down' && this.py < 250) this.py += 25;
            if(k === 'A' || k === 'right') { 
                this.bullets.push({x: 40, y: this.py, vx: 8});
                sfx('shoot'); 
            }
        }
        update() {
            this.t++;
            // Bullets aage badhao
            for(let i = this.bullets.length-1; i >= 0; i--) {
                this.bullets[i].x += this.bullets[i].vx;
                if(this.bullets[i].x > 300) this.bullets.splice(i, 1);
            }

            // Dushman (Enemies) Spawn karo
            let spawnRate = Math.max(15, 45 - Math.floor(score/50));
            if(this.t % spawnRate === 0) {
                this.enemies.push({x: 320, y: Math.random() * 200 + 40, vx: - (3 + Math.random()*2 + score/200)});
            }

            // Enemies aage badhao aur collision check karo
            for(let i = this.enemies.length-1; i >= 0; i--) {
                let e = this.enemies[i];
                e.x += e.vx;
                
                // Agar dushman tumhare paas pahuch gaya = Game Over
                if(e.x < 10) { spawnParticles(20, this.py, '#ff4757', 30); return false; } 

                // Goli dushman ko lagi?
                for(let j = this.bullets.length-1; j >= 0; j--) {
                    let b = this.bullets[j];
                    if(Math.abs(b.x - e.x) < 18 && Math.abs(b.y - e.y) < 18) {
                        spawnParticles(e.x, e.y, '#fd79a8');
                        this.enemies.splice(i, 1);
                        this.bullets.splice(j, 1);
                        score += 10;
                        sfx('hit');
                        break;
                    }
                }
                
                // Direct takkar
                if(this.enemies[i] && Math.abs(this.enemies[i].x - 20) < 20 && Math.abs(this.enemies[i].y - this.py) < 20) {
                    return false;
                }
            }
            return true;
        }
        draw() {
            // Shadow Theme Background
            ctx.fillStyle = '#1e272e'; ctx.fillRect(0, 0, 300, 300);
            ctx.fillStyle = 'rgba(253, 121, 168, 0.2)'; ctx.beginPath(); ctx.arc(250, 60, 40, 0, Math.PI*2); ctx.fill(); // Blood Moon
            
            // Draw Player (Shadow Ninja)
            ctx.fillStyle = '#000'; // Pure black shadow
            ctx.fillRect(15, this.py - 15, 15, 30); // Body
            ctx.fillRect(18, this.py - 25, 10, 10); // Head
            ctx.fillStyle = '#00d2d3'; ctx.fillRect(23, this.py - 22, 5, 3); // Neon Cyan Eye
            
            // Draw Shurikens (Bullets)
            ctx.fillStyle = '#00d2d3';
            this.bullets.forEach(b => {
                ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill();
            });

            // Draw Enemies (Red-eyed Shadows)
            ctx.fillStyle = '#2d3436'; 
            this.enemies.forEach(e => {
                ctx.fillRect(e.x - 10, e.y - 15, 15, 30);
                ctx.fillStyle = '#ff4757'; ctx.fillRect(e.x - 5, e.y - 22, 5, 3); // Red Eye
                ctx.fillStyle = '#2d3436';
            });
        }
    }


    // --- Main Game Loop ---
    function loop() {
        if(state === 'MENU') {
            drawAnimatedBG();
            
            ctx.textAlign = 'center';
            ctx.fillStyle = '#fd79a8'; ctx.font = 'bold 24px Courier New'; 
            ctx.shadowBlur = 10; ctx.shadowColor = '#fd79a8';
            ctx.fillText("SELECT GAME", 150, 45);
            ctx.shadowBlur = 0;
            
            // Scrolling Menu Logic
            games.forEach((g, i) => {
                let y = 150 + (i - selIdx) * 35; 
                if(y > 70 && y < 270) {
                    if(i === selIdx) {
                        ctx.fillStyle = 'rgba(0, 210, 211, 0.2)'; ctx.fillRect(20, y - 22, 260, 30); 
                        ctx.fillStyle = '#00d2d3'; ctx.font = 'bold 20px Courier New';
                        ctx.shadowBlur = 8; ctx.shadowColor = '#00d2d3'; // Neon Text Glow
                        ctx.fillText(">> " + g + " <<", 150, y);
                        ctx.shadowBlur = 0;
                    } else {
                        ctx.fillStyle = '#747d8c'; ctx.font = '16px Courier New';
                        ctx.fillText(g, 150, y);
                    }
                }
            });
            ctx.fillStyle = '#ffff00'; ctx.font = '12px Courier New';
            ctx.fillText("BEST SCORE: " + getHighScore(selIdx), 150, 290);

        } else if(state === 'PLAY') {
            if(!isPaused) {
                if(!currGame.update()) { 
                    state = 'GAMEOVER'; sfx('hit'); setHighScore(selIdx, score);
                }
                particles = particles.filter(p => p.life > 0);
                particles.forEach(p => p.update());
            }

            currGame.draw();
            particles.forEach(p => p.draw(ctx));

            // Score UI
            ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(0, 0, 300, 25);
            ctx.fillStyle = '#fff'; ctx.font = '14px Courier New'; ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
            ctx.fillText("SCORE: " + score, 10, 18);
            ctx.textAlign = 'right'; ctx.fillStyle = '#00d2d3';
            ctx.fillText("HI: " + Math.max(score, highScore), 290, 18);

            if(isPaused) {
                ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0,0,300,300);
                ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; 
                ctx.font = '30px Courier New'; ctx.fillText("PAUSED", 150, 150);
            }

        } else if(state === 'GAMEOVER') {
            currGame.draw(); 
            ctx.fillStyle = 'rgba(15, 12, 41, 0.9)'; ctx.fillRect(20, 80, 260, 140);
            ctx.strokeStyle = '#fd79a8'; ctx.lineWidth = 3; ctx.strokeRect(20, 80, 260, 140);
            
            ctx.fillStyle = '#ff4757'; ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
            ctx.font = 'bold 30px Courier New'; ctx.fillText("GAME OVER", 150, 120);
            
            ctx.fillStyle = '#fff'; ctx.font = '16px Courier New'; ctx.fillText("Score: " + score, 150, 150);
            if(score >= highScore && score > 0) { ctx.fillStyle = '#ffff00'; ctx.fillText("NEW RECORD!", 150, 170); }
            
            ctx.fillStyle = '#00d2d3'; ctx.font = '12px Courier New';
            ctx.fillText("A: MENU  |  B: RETRY", 150, 200);
        }
        
        requestAnimationFrame(loop);
    }

    loop();
</script>
</body>
                                                                                                             </html>
